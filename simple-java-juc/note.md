1. 并发编程的3大核心：分工、同步（协作）、互斥
    分工：excutor与线程池、fork/join、future、生产者消费者模式
    协作：信号量（semaphore）、管程（monitor）、countDownLatch、cyclicBarrier、hpaser、exchanger
    互斥：互斥锁（synchronized、lock、读写锁）；无锁（不变模式--final、线程本地存储--threadLocal、CAS、Copy-on-write、原子类）
2. 造成线程安全的主要原因：可见性问题（缓存导致），有序性问题（编译器优化导致），原子性问题（线程切换导致）
    java内存模型，volatile、happen-before规则，用来解决可见性问题和有序性问题，
    原子性问题要靠锁来解决，引入锁会带来性能问题，javaSDK并发包里面的各种工具类主要是为了解决不同场景下的性能问题
3. 解决可见性和有序性的根本解决办法就是禁用缓存和禁止重排序
    java内存模型本质上就是提供方法用来禁用缓存和禁止编译优化，包括volatile、synchronized、final三个关键字，以及6项Happens-Before规则
    Happens-Before规则：
    顺序性规则
    volatile变量规则，对于一个volatile变量的写操作happens-before对于这个变量的写操作
    传递性规则
    锁规则，一个锁的解锁操作happens-before后续对这个锁的加锁操作
    线程的start()规则
    线程join()规则
4. 死锁，死锁发生的4个必须条件：
    互斥，共享资源只能被一个线程占用；
    占有且等待，占有共享资源X的同时等待共享资源Y，且不释放占有的资源X；
    不可抢占，其他线程不能强行占有线程1占有的资源；
    循环等待，线程1占用X的资源等待Y的资源，线程2占用Y的资源等待X的资源
5. 并发编程需要注意的三大问题：
    安全性问题；数据竞争，竞态条件
    活跃性问题；死锁，活锁，饥饿
    性能问题；吞吐量，延迟，并发量，优先使用无锁数据结构和算法，减少持有锁的时间
6. java线程的生命周期
    new（初始化状态）
    runnable（可运行/运行状态）
    blocked（阻塞状态） ---- 没有 CPU 的使用权
    waiting（无限时等待状态） ---- 没有 CPU 的使用权
    timed_waiting（限时等待状态） ---- 没有 CPU 的使用权
    terminated（终止状态）
7. 线程的stop()方法和interrupt()方法的区别
    stop()方法会真的杀死线程，不给线程喘息的机会，如果线程持有lock.lock()锁的话，被杀死是不会自动释放锁的，类似的方法还有 suspend() 和 resume() 方法
    而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，
    是怎么收到通知的呢？一种是异常，另一种是主动检测。
8. 使用多线程主要是为了提升性能，也就是降低延迟，提升吞吐量
    创建合适的线程数：对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，
                   再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上， 
                   线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。
                   对于 IO 密集型，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]
    如果不清楚是什么类型，可以根据经验值设置 2 * CPU 的核数 + 1 ，在根据压测结果进行修改
9. 用面向对象的思想来编写并发程序
    首先，将共享变量封装到对象内部，针对对外提供的公共方法制定相应的并发访问策略，对于不会发生变化的共享变量，用final来修饰；
    其次，如果有多个共享变量，要识别共享变量之间的约束条件，比如库存上下限，上限要 >= 下限；
    优先使用成熟的工具类，javaSDK提供了丰富的工具类，不要自己造轮子，难度比较大；
    迫不得已才使用低级同步源语，包括 synchronized, lock, semaphore等；
    避免过早优化，并发程序首先要保证安全第一，出现性能问题再开始优化，毕竟性能问题不是能预估的到的
10. 用锁的最佳实践
    永远只在更新对象的成员变量时加锁；
    永远只在访问对象的成员变量时加锁；
    永远不在调用其他对象的方法时加锁。
11. 信号量（Semaphore）
    信号量模型简单概括为：一个计数器，一个等待队列，三个方法，见图semaphore.jpg
    init()方法设置计数器的初始值；
    down()方法计数器的值减1，如果当前计数器的值小于0，当前线程阻塞，否则可以继续执行；
    up()方法，计数器的值加1，如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。
       注：为什么 <= 0要唤醒呢?,因为如果 > 0的话，说明资源足够，阻塞队列里面就没有待唤醒的线程
12. 读写锁（ReadWriteLock）使用场景，读多写少，基本特性：
    允许多个线程同时读共享变量；
    只允许一个线程写共享变量；
    如果一个写线程正在执行写操作，那么禁止读线程读共享变量
    读写锁不允许锁的升级，但是允许锁的降级














    